package handler

import (
	"bufio"
	"errors"
	"fmt"
	"os"
	"os/exec"
	"runtime"
	"sort"
	"strings"
	"syscall"

	"encoding/csv"

	"github.com/yuanpli/datamgr-cli/db"
	"github.com/xuri/excelize/v2"
	"golang.org/x/term"
)

// HandleHelp 帮助命令处理
func HandleHelp() {
	helpText := `
可用命令:
  系统命令:
    help                   - 显示此帮助信息
    connect                - 连接数据库
    status                 - 显示连接状态
    exit, quit             - 退出程序
    clear                  - 清屏

  表管理命令:
    show tables            - 列出所有表
    desc table <表名>      - 显示表结构

  数据操作命令:
    SELECT [字段] FROM <表> [WHERE 条件] [LIMIT 数量]  - 查询数据
    INSERT INTO <表> SET 字段1=值1, 字段2=值2...      - 插入数据
    UPDATE <表> SET 字段=值 [WHERE 条件]             - 更新数据
    DELETE FROM <表> [WHERE 条件]                    - 删除数据
    IMPORT <表> FROM <文件> [FORMAT csv/excel]       - 导入数据
    EXPORT <表> [WHERE 条件] <文件> [FORMAT csv/excel] - 导出数据
`
	fmt.Println(helpText)
}

// HandleClear 清屏命令处理
func HandleClear() {
	var cmd *exec.Cmd
	if runtime.GOOS == "windows" {
		cmd = exec.Command("cmd", "/c", "cls")
	} else {
		cmd = exec.Command("clear")
	}
	cmd.Stdout = os.Stdout
	cmd.Run()
}

// HandleStatus 状态命令处理
func HandleStatus() error {
	config := db.GetCurrentConfig()
	if config == nil {
		return errors.New("当前未连接到任何数据库")
	}

	fmt.Println("当前连接状态:")
	fmt.Printf("  数据库类型: %s\n", config.Type)
	fmt.Printf("  主机地址: %s\n", config.Host)
	fmt.Printf("  端口: %d\n", config.Port)
	fmt.Printf("  用户名: %s\n", config.User)
	fmt.Printf("  数据库名: %s\n", config.DbName)
	return nil
}

// HandleConnect 处理连接命令
func HandleConnect(cmdStr string) error {
	// 简单解析connect命令
	args := strings.Fields(cmdStr)
	if len(args) == 1 {
		// 交互式连接向导
		return handleInteractiveConnect()
	}

	// 解析命令行参数
	var dbType, host, user, password, dbName string
	var port int = 5236 // 默认端口

	for i := 1; i < len(args); i++ {
		switch args[i] {
		case "--type":
			if i+1 < len(args) {
				dbType = args[i+1]
				i++
			}
		case "-h", "--host":
			if i+1 < len(args) {
				host = args[i+1]
				i++
			}
		case "-P", "--port":
			if i+1 < len(args) {
				fmt.Sscanf(args[i+1], "%d", &port)
				i++
			}
		case "-u", "--user":
			if i+1 < len(args) {
				user = args[i+1]
				i++
			}
		case "-p", "--password":
			if i+1 < len(args) {
				password = args[i+1]
				i++
			}
		case "-D", "--dbname":
			if i+1 < len(args) {
				dbName = args[i+1]
				i++
			}
		}
	}

	// 如果没有指定数据库类型，默认为达梦
	if dbType == "" {
		dbType = "dameng"
	}

	// 验证必要参数
	if host == "" || user == "" || password == "" || dbName == "" {
		return errors.New("连接参数不完整，请提供主机、用户名、密码和数据库名")
	}

	// 执行连接
	err := db.Connect(dbType, host, port, user, password, dbName)
	if err != nil {
		return err
	}

	fmt.Printf("已成功连接到 %s 数据库: %s\n", dbType, dbName)
	return nil
}

// readInput 实时显示用户输入
func readInput(prompt string) string {
	fmt.Print(prompt)
	var input []byte
	var b [1]byte
	
	for {
		_, err := os.Stdin.Read(b[:])
		if err != nil {
			return ""
		}
		
		// 回车键结束输入
		if b[0] == '\n' || b[0] == '\r' {
			fmt.Println()
			return string(input)
		}
		
		// 处理退格键
		if b[0] == 127 || b[0] == 8 {
			if len(input) > 0 {
				input = input[:len(input)-1]
				fmt.Print("\b \b") // 退格、空格、再退格
			}
			continue
		}
		
		// 将输入字符添加到输入数组
		input = append(input, b[0])
		fmt.Print(string(b[0])) // 立即打印输入字符
	}
}

// readPassword 读取密码但不显示
func readPassword(prompt string) string {
	fmt.Print(prompt)
	password, err := term.ReadPassword(int(syscall.Stdin))
	fmt.Println() // 换行
	if err != nil {
		return ""
	}
	return string(password)
}

// handleInteractiveConnect 交互式连接向导
func handleInteractiveConnect() error {
	fmt.Println("请输入连接信息:")

	var dbType, host, user, password, dbName string
	var port int

	// 默认使用达梦数据库
	dbType = "dameng"
	port = 5236

	// 获取主机地址
	host = readInput("主机地址: ")
	
	// 获取端口
	portStr := readInput("端口 (默认 5236): ")
	if portStr != "" {
		fmt.Sscanf(portStr, "%d", &port)
	}
	
	// 获取用户名
	user = readInput("用户名: ")
	
	// 获取密码
	password = readPassword("密码: ")
	
	// 获取数据库名
	dbName = readInput("数据库名: ")

	if host == "" || user == "" || password == "" || dbName == "" {
		return errors.New("连接参数不完整，请提供主机、用户名、密码和数据库名")
	}

	err := db.Connect(dbType, host, port, user, password, dbName)
	if err != nil {
		return err
	}

	fmt.Printf("已成功连接到 %s 数据库: %s\n", dbType, dbName)
	return nil
}

// HandleShowTables 显示表列表
func HandleShowTables() error {
	conn := db.GetCurrentConnection()
	if conn == nil {
		return errors.New("当前未连接到任何数据库")
	}

	tables, err := conn.GetTables()
	if err != nil {
		return err
	}

	if len(tables) == 0 {
		fmt.Println("数据库中没有找到表")
		return nil
	}

	fmt.Println("表列表:")
	for i, table := range tables {
		fmt.Printf("%3d) %s\n", i+1, table)
	}

	return nil
}

// HandleDescribeTable 显示表结构
func HandleDescribeTable(tableName string) error {
	conn := db.GetCurrentConnection()
	if conn == nil {
		return errors.New("当前未连接到任何数据库")
	}

	columns, err := conn.DescribeTable(tableName)
	if err != nil {
		return err
	}

	if len(columns) == 0 {
		return fmt.Errorf("表 %s 不存在或没有字段", tableName)
	}

	// 打印表头
	fmt.Printf("\n表 %s 的结构:\n", tableName)
	fmt.Printf("%-20s %-15s %-10s %-10s %-15s %-30s\n", "字段名", "数据类型", "长度", "可空", "约束", "描述")
	fmt.Println(strings.Repeat("-", 105))

	for _, col := range columns {
		colName := fmt.Sprintf("%v", col["COLUMN_NAME"])
		dataType := fmt.Sprintf("%v", col["DATA_TYPE"])
		dataLength := fmt.Sprintf("%v", col["DATA_LENGTH"])
		nullable := fmt.Sprintf("%v", col["NULLABLE"])
		constraint := fmt.Sprintf("%v", col["CONSTRAINT_TYPE"])
		description := fmt.Sprintf("%v", col["DESCRIPTION"])

		fmt.Printf("%-20s %-15s %-10s %-10s %-15s %-30s\n",
			colName, dataType, dataLength, nullable, constraint, description)
	}
	fmt.Println()

	return nil
}

// HandleImport 处理导入命令
func HandleImport(cmdStr string) error {
	// 解析命令
	// IMPORT <table> FROM <file> [FORMAT csv/excel]
	parts := strings.Fields(cmdStr)
	if len(parts) < 3 {
		return errors.New("用法: IMPORT <表名> FROM <文件名> [FORMAT csv/excel]")
	}

	// 获取表名
	tableName := parts[1]
	
	var filePath string
	var format string = FormatCSV // 默认为CSV
	
	// 解析命令参数
	i := 2
	for i < len(parts) {
		switch strings.ToUpper(parts[i]) {
		case "FORMAT":
			if i+1 < len(parts) {
				format = strings.ToLower(parts[i+1])
				i += 2
			} else {
				i++
			}
		default:
			// 检查是否是文件路径
			if strings.HasSuffix(strings.ToLower(parts[i]), ".csv") || strings.HasSuffix(strings.ToLower(parts[i]), ".xlsx") {
				filePath = parts[i]
				// 根据文件扩展名判断格式
				if strings.HasSuffix(strings.ToLower(parts[i]), ".xlsx") {
					format = FormatExcel
				} else {
					format = FormatCSV
				}
			}
			i++
		}
	}
	
	if filePath == "" {
		return errors.New("必须指定导入文件路径")
	}
	
	// 验证格式
	if format != FormatCSV && format != FormatExcel {
		return fmt.Errorf("不支持的导入格式: %s，支持的格式为: csv, excel", format)
	}
	
	// 开始导入数据
	err := handleImport(tableName, filePath, format)
	if err != nil {
		return err
	}
	
	fmt.Printf("成功导入 %s 表的数据到 %s\n", tableName, filePath)
	return nil
}

// readCSV 读取CSV文件
func readCSV(filePath string) ([][]string, []string, error) {
	// 打开文件
	file, err := os.Open(filePath)
	if err != nil {
		return nil, nil, err
	}
	defer file.Close()
	
	// 创建带缓冲的读取器，处理BOM
	reader := bufio.NewReader(file)
	
	// 检测并跳过BOM
	bom := make([]byte, 3)
	_, _ = reader.Read(bom)
	if bom[0] != 0xEF || bom[1] != 0xBB || bom[2] != 0xBF {
		// 不是BOM，将文件指针重置
		file.Seek(0, 0)
		reader = bufio.NewReader(file)
	}
	
	// 创建CSV读取器
	csvReader := csv.NewReader(reader)
	
	// 读取所有记录
	records, err := csvReader.ReadAll()
	if err != nil {
		return nil, nil, err
	}
	
	if len(records) < 1 {
		return nil, nil, errors.New("CSV文件为空")
	}
	
	// 提取表头和数据
	headers := records[0]
	data := records[1:]
	
	return data, headers, nil
}

// readExcel 读取Excel文件
func readExcel(filePath string) ([][]string, []string, error) {
	// 打开Excel文件
	f, err := excelize.OpenFile(filePath)
	if err != nil {
		return nil, nil, err
	}
	defer f.Close()
	
	// 获取第一个工作表名称
	sheets := f.GetSheetList()
	if len(sheets) == 0 {
		return nil, nil, errors.New("Excel文件不包含工作表")
	}
	sheetName := sheets[0]
	
	// 读取所有行
	rows, err := f.GetRows(sheetName)
	if err != nil {
		return nil, nil, err
	}
	
	if len(rows) < 1 {
		return nil, nil, errors.New("Excel工作表为空")
	}
	
	// 提取表头和数据
	headers := rows[0]
	data := rows[1:]
	
	return data, headers, nil
}

// 导出格式
const (
	FormatCSV   = "csv"
	FormatExcel = "excel"
)

// HandleExport 处理导出命令
func HandleExport(cmdStr string) error {
	// 解析命令
	// EXPORT <table> [WHERE 条件] <file> [FORMAT csv/excel]
	parts := strings.Fields(cmdStr)
	if len(parts) < 3 {
		return errors.New("用法: EXPORT <表名> [WHERE 条件] <文件名> [FORMAT csv/excel]")
	}

	// 获取表名
	tableName := parts[1]
	
	var whereClause string
	var filePath string
	var format string = FormatCSV // 默认为CSV
	
	// 解析命令参数
	i := 2
	for i < len(parts) {
		switch strings.ToUpper(parts[i]) {
		case "WHERE":
			// 寻找WHERE子句的结束位置
			start := i + 1
			end := start
			for end < len(parts) && strings.ToUpper(parts[end]) != "FORMAT" && !strings.HasSuffix(parts[end], ".csv") && !strings.HasSuffix(parts[end], ".xlsx") {
				end++
			}
			if start < end {
				whereClause = strings.Join(parts[start:end], " ")
			}
			i = end
		case "FORMAT":
			if i+1 < len(parts) {
				format = strings.ToLower(parts[i+1])
				i += 2
			} else {
				i++
			}
		default:
			// 检查是否是文件路径
			if strings.HasSuffix(strings.ToLower(parts[i]), ".csv") || strings.HasSuffix(strings.ToLower(parts[i]), ".xlsx") {
				filePath = parts[i]
				// 根据文件扩展名判断格式
				if strings.HasSuffix(strings.ToLower(parts[i]), ".xlsx") {
					format = FormatExcel
				} else {
					format = FormatCSV
				}
			}
			i++
		}
	}
	
	if filePath == "" {
		return errors.New("必须指定导出文件路径")
	}
	
	// 验证格式
	if format != FormatCSV && format != FormatExcel {
		return fmt.Errorf("不支持的导出格式: %s，支持的格式为: csv, excel", format)
	}
	
	// 先获取表结构信息
	conn := db.GetCurrentConnection()
	if conn == nil {
		return errors.New("当前未连接到任何数据库")
	}
	
	tableInfo, err := conn.DescribeTable(tableName)
	if err != nil {
		return fmt.Errorf("获取表结构失败: %v", err)
	}
	
	// 创建字段名到描述的映射
	fieldDescriptions := make(map[string]string)
	for _, col := range tableInfo {
		colName := fmt.Sprintf("%v", col["COLUMN_NAME"])
		description := fmt.Sprintf("%v", col["DESCRIPTION"])
		fieldDescriptions[strings.ToUpper(colName)] = description
	}
	
	// 构建查询SQL
	sql := fmt.Sprintf("SELECT * FROM %s", tableName)
	if whereClause != "" {
		sql += " WHERE " + whereClause
	}
	
	// 执行查询
	results, err := conn.Query(sql)
	if err != nil {
		return err
	}
	
	if len(results) == 0 {
		return errors.New("没有找到符合条件的数据")
	}
	
	// 导出数据
	switch format {
	case FormatCSV:
		err = exportToCSV(results, filePath, fieldDescriptions)
	case FormatExcel:
		err = exportToExcel(results, filePath, fieldDescriptions)
	}
	
	if err != nil {
		return err
	}
	
	fmt.Printf("成功导出 %d 条记录到 %s\n", len(results), filePath)
	return nil
}

// exportToCSV 导出数据到CSV文件
func exportToCSV(data []map[string]interface{}, filePath string, fieldDescriptions map[string]string) error {
	if len(data) == 0 {
		return errors.New("没有数据可导出")
	}
	
	// 创建文件
	file, err := os.Create(filePath)
	if err != nil {
		return err
	}
	defer file.Close()
	
	// 写入UTF-8 BOM，解决中文乱码问题
	_, err = file.WriteString("\xEF\xBB\xBF")
	if err != nil {
		return err
	}
	
	// 创建CSV写入器
	writer := csv.NewWriter(file)
	defer writer.Flush()
	
	// 提取列名
	var headers []string
	var displayHeaders []string
	for header := range data[0] {
		headers = append(headers, header)
	}
	sort.Strings(headers) // 确保列顺序一致
	
	// 准备显示标题 - 优先使用描述，如果没有描述则使用字段名
	for _, header := range headers {
		// 尝试获取字段描述
		description := fieldDescriptions[strings.ToUpper(header)]
		if description != "" && description != "<nil>" {
			displayHeaders = append(displayHeaders, description)
		} else {
			displayHeaders = append(displayHeaders, header)
		}
	}
	
	// 写入表头
	if err := writer.Write(displayHeaders); err != nil {
		return err
	}
	
	// 写入数据行
	for _, record := range data {
		var row []string
		for _, header := range headers {
			// 将各种类型转换为字符串
			var cell string
			if record[header] == nil {
				cell = ""
			} else {
				cell = fmt.Sprintf("%v", record[header])
			}
			row = append(row, cell)
		}
		if err := writer.Write(row); err != nil {
			return err
		}
	}
	
	return nil
}

// exportToExcel 导出数据到Excel文件
func exportToExcel(data []map[string]interface{}, filePath string, fieldDescriptions map[string]string) error {
	if len(data) == 0 {
		return errors.New("没有数据可导出")
	}
	
	// 创建一个新的Excel文件
	f := excelize.NewFile()
	
	// 默认的工作表名称
	sheetName := "Sheet1"
	
	// 提取列名
	var headers []string
	var displayHeaders []string
	for header := range data[0] {
		headers = append(headers, header)
	}
	sort.Strings(headers) // 确保列顺序一致
	
	// 准备显示标题 - 优先使用描述，如果没有描述则使用字段名
	for _, header := range headers {
		// 尝试获取字段描述
		description := fieldDescriptions[strings.ToUpper(header)]
		if description != "" && description != "<nil>" {
			displayHeaders = append(displayHeaders, description)
		} else {
			displayHeaders = append(displayHeaders, header)
		}
	}
	
	// 写入表头
	for i, displayHeader := range displayHeaders {
		cell, _ := excelize.CoordinatesToCellName(i+1, 1)
		f.SetCellValue(sheetName, cell, displayHeader)
	}
	
	// 写入数据行
	for rowIdx, record := range data {
		for colIdx, header := range headers {
			cell, _ := excelize.CoordinatesToCellName(colIdx+1, rowIdx+2)
			f.SetCellValue(sheetName, cell, record[header])
		}
	}
	
	// 保存文件
	if err := f.SaveAs(filePath); err != nil {
		return err
	}
	
	// 关闭文件
	if err := f.Close(); err != nil {
		return err
	}
	
	return nil
}

// interfaceSlice 将字符串切片转换为接口切片
func interfaceSlice(slice []string) []interface{} {
	iSlice := make([]interface{}, len(slice))
	for i, v := range slice {
		iSlice[i] = v // 不再使用颜色包装，避免显示问题
	}
	return iSlice
} 